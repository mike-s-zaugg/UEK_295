// scripts/generate-module-readmes.mjs
//
// Generates per-module README files from OpenAPI + per-module ERD/Entity metadata.
// Inputs:
// - docs/openapi.json
// - docs/<module>/_erd.md            (generated by scripts/generate-erd-per-module.mjs)
// - docs/<module>/_entities.json     (also generated by scripts/generate-erd-per-module.mjs)
//
// Output:
// - docs/<module>/README.md
//
// Notes:
// - Groups endpoints by path: /api/<module>/...
// - Adds Mermaid sequence diagrams with status code labels + response types
// - Adds DTO Mermaid classDiagram + TypeScript DTO classes (from OpenAPI schemas)
// - Adds Entities Mermaid ERD + TypeScript Entity classes (from TypeORM metadata JSON)
//
import fs from 'node:fs';
import path from 'node:path';
import * as util from './util.mjs';

function createMermaidImage(inputFileName) {
  const mmdc = path.resolve(
    'node_modules',
    '.bin',
    process.platform === 'win32' ? 'mmdc.cmd' : 'mmdc',
  );

  const outputFileName = inputFileName.replace('.mmd', '.png');
  util.runCommand(mmdc, [
    '-i',
    inputFileName,
    '-o',
    outputFileName,
    '--scale',
    '3',
    '-b',
    'transparent',
  ])
    .then(() => {
      console.log(`Diagramm ${outputFileName} erstellt ‚úÖ??`);
    })
    .catch((err) => {
      console.error('Mermaid-Rendering fehlgeschlagen ‚ùå');
      console.error(err.message);
      throw err; // üî• wichtig, wenn der Build abbrechen soll
    });
}

const OPENAPI_PATH = 'docs/openapi.json';
const DOCS_DIR = 'docs';

if (!fs.existsSync(OPENAPI_PATH)) {
  throw new Error(
    `OpenAPI file not found at "${OPENAPI_PATH}". Run your OpenAPI export first.`,
  );
}

const spec = JSON.parse(fs.readFileSync(OPENAPI_PATH, 'utf8'));

const STATUS_LABELS = {
  200: 'OK',
  201: 'Created',
  204: 'No Content',
  400: 'Bad Request',
  401: 'Unauthorized',
  403: 'Forbidden',
  404: 'Not Found',
  409: 'Conflict',
  422: 'Unprocessable Entity',
  500: 'Internal Server Error',
};

function statusLabel(code) {
  return STATUS_LABELS[code] ?? code;
}

function schemaNameFromRef(ref) {
  return ref?.split('/').pop();
}

function schemaToType(schema) {
  if (!schema) return null;
  if (schema.$ref) return schemaNameFromRef(schema.$ref);
  if (schema.type === 'array' && schema.items?.$ref) {
    return `${schemaNameFromRef(schema.items.$ref)}[]`;
  }
  if (schema.type) return schema.type;
  return null;
}

// function requestBodyType(op) {
//   const schema = op.requestBody?.content?.['application/json']?.schema;
//   return schemaToType(schema);
// }

function responseTypeForStatus(op, status) {
  const res = op.responses?.[status];
  const schema = res?.content?.['application/json']?.schema;
  return schemaToType(schema);
}

function guessReturnType(op) {
  // prefer 201 over 200, then fall back
  const res = op.responses?.['201'] || op.responses?.['200'];
  const schema = res?.content?.['application/json']?.schema;
  return schemaToType(schema) ?? 'unknown';
}

function listParams(op) {
  const params = op.parameters || [];
  if (!params.length) return '';
  let out = `**Parameters:**\n\n`;
  for (const p of params) {
    out += `- \`${p.name}\` (${p.in}) ${p.schema?.type ?? ''}\n`;
  }
  return out;
}

function bodySchemaName(op) {
  const s = op.requestBody?.content?.['application/json']?.schema;
  if (!s) return null;
  if (s.$ref) return schemaNameFromRef(s.$ref);
  return null;
}

function collectSchemaRefs(obj, set) {
  if (!obj || typeof obj !== 'object') return;
  if (obj.$ref) set.add(schemaNameFromRef(obj.$ref));
  for (const v of Object.values(obj)) collectSchemaRefs(v, set);
}

async function classDiagramForSchemas(moduleName, schemaNames) {
  const schemas = spec.components?.schemas || {};
  let classDiagramSchemas = '';
  let first = true;
  for (const name of [...schemaNames].sort()) {
    const sch = schemas[name];
    if (!sch) continue;
    let out = 'classDiagram\n';

    out += `  class ${name} {\n`;
    const props = sch.properties || {};

    for (const [p, meta] of Object.entries(props)) {
      const t = meta.$ref
        ? schemaNameFromRef(meta.$ref)
        : meta.type === 'array' && meta.items?.$ref
          ? `${schemaNameFromRef(meta.items.$ref)}[]`
          : meta.type || 'any';
      out += `    +${t} ${p}\n`;
    }

    out += '  }\n\n';

    // create the file
    const dir = path.join(DOCS_DIR, moduleName, 'schemaDiagrams');
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    const fileNameSchema = path.join(name + '.mmd');
    const fullFileNameMermaidSchema = path.join(dir, fileNameSchema);
    fs.writeFileSync(fullFileNameMermaidSchema, out, 'utf8');

    // create ths png
    createMermaidImage(fullFileNameMermaidSchema);

    const anchor = util.toAnchorId(name)+'-schema';
    if (!first) {
      classDiagramSchemas += '\\newpage\n\n';
    }
    classDiagramSchemas += `### ${name} - Schema Diagram {#${anchor}}\n\n`;
    classDiagramSchemas += `![${name} - Schema Diagram](./schemaDiagrams/${path.join(name + '.png')}){height="500px"}\n`;
    classDiagramSchemas += `\n\n`;
    first = false;
  }

  classDiagramSchemas += '\n';

  return classDiagramSchemas;
}

// ---------- DTO TS classes (from OpenAPI) ----------
function openApiTypeToTs(meta) {
  if (!meta || typeof meta !== 'object') return 'any';

  if (meta.$ref) return schemaNameFromRef(meta.$ref);

  if (meta.type === 'array') {
    const item = meta.items;
    const t = item?.$ref ? schemaNameFromRef(item.$ref) : openApiTypeToTs(item);
    return `${t}[]`;
  }

  switch (meta.type) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

function tsDtoClassForSchema(name, schema) {
  if (!schema || typeof schema !== 'object') {
    return `export class ${name} {}`;
  }

  // handle allOf/oneOf/anyOf best-effort -> type alias
  if (Array.isArray(schema.allOf) && schema.allOf.length) {
    const parts = schema.allOf.map((s) => openApiTypeToTs(s));
    return `export type ${name} = ${parts.join(' & ')};`;
  }
  if (Array.isArray(schema.oneOf) && schema.oneOf.length) {
    const parts = schema.oneOf.map((s) => openApiTypeToTs(s));
    return `export type ${name} = ${parts.join(' | ')};`;
  }
  if (Array.isArray(schema.anyOf) && schema.anyOf.length) {
    const parts = schema.anyOf.map((s) => openApiTypeToTs(s));
    return `export type ${name} = ${parts.join(' | ')};`;
  }

  const required = new Set(schema.required || []);
  const props = Object.entries(schema.properties || {}).map(([prop, meta]) => {
    const optional = required.has(prop) ? '' : '?';
    return `  ${prop}${optional}: ${openApiTypeToTs(meta)};`;
  });

  return `export class ${name} {\n${props.join('\n')}\n}`;
}

function tsDtoClassSchemas(schemaNames) {
  const schemas = spec.components?.schemas || {};
  let classDia = `\n`;
  for (const name of [...schemaNames].sort()) {
    const schema = schemas[name];
    if (!schema) continue;

    const anchor = util.toAnchorId(name);
    classDia += `### ${name} {#${anchor}}\n\n`;
    classDia += `\`\`\`ts\n${tsDtoClassForSchema(name, schema)}\n\`\`\`\n\n`;
  }
  return classDia;
}

// ---------- Entity TS classes (from TypeORM metadata JSON) ----------
function normalizeEntityColTypeToTs(type) {
  // typeorm metadata often already normalized to strings like "varchar", "numeric", ...
  // We keep them as-is or map a few common ones.
  const t = String(type || 'unknown').toLowerCase();

  if (t.includes('int') || t === 'integer' || t === 'number') return 'number';
  if (
    t.includes('char') ||
    t.includes('text') ||
    t === 'string' ||
    t === 'varchar'
  )
    return 'string';
  if (t.includes('bool')) return 'boolean';
  if (t.includes('date') || t.includes('time')) return 'Date';
  if (
    t.includes('numeric') ||
    t.includes('decimal') ||
    t.includes('float') ||
    t.includes('double')
  )
    return 'number';

  // fallback: keep a reasonable TS type
  return 'any';
}

function entityClassFromMeta(meta) {
  const lines = [];
  lines.push(`export class ${meta.name} {`);
  for (const c of meta.columns || []) {
    const tsType = normalizeEntityColTypeToTs(c.type);
    // best-effort optional marker: make non-primary optional (doc-friendly)
    const optional = c.isPrimary ? '' : '?';
    lines.push(`  ${c.databaseName}${optional}: ${tsType};`);
  }
  lines.push('}');
  return lines.join('\n');
}

function tsEntityClassesForModule(moduleName) {
  const metaPath = path.join(DOCS_DIR, moduleName, 'entities', '_entities.json');
  if (!fs.existsSync(metaPath)) return null;
  let entityTs = '\n';
  const metas = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
  if (!Array.isArray(metas) || metas.length === 0) return '';
  let first = true;
  for (const meta of metas) {
    if (!meta?.name) continue;
    const anchor = util.toAnchorId(meta.name);
    if (!first) {
      entityTs += '\\newpage\n';
    }
    entityTs += `### ${meta.name} - TypeScript Class Definition {#${anchor}}\n\n`;
    entityTs += `\`\`\`ts\n${entityClassFromMeta(meta)}\n\`\`\`\n\n`;
  }
  return entityTs;
}

// ---------- Mermaid sequence diagrams with status labels + types ----------
async function sequenceDiagram(moduleName, method, fullPath, op) {
  // const reqType = requestBodyType(op);
  const statuses = Object.keys(op.responses || {}).sort((a, b) => {
    // numeric sort, keep "default" last
    if (a === 'default') return 1;
    if (b === 'default') return -1;
    return Number(a) - Number(b);
  });

  // const labelReq = reqType
  //   ? `${method} ${fullPath} (${reqType})`
  //   : `${method} ${fullPath}`;
  const labelReq = `${method} ${fullPath}`;

  const altBlocks = statuses
    .map((code, idx) => {
      const t = responseTypeForStatus(op, code);
      const human = statusLabel(code);
      const label = t ? `${code} ${human} (${t})` : `${code} ${human}`;
      const kw = idx === 0 ? 'alt' : 'else';
      return `  ${kw} \n    API --> Client: ${label}\n`;
    })
    .join('');

  const note = op.security?.length > 0 ? 'Endpoint requires authentication': 'Public endpoint';

  const seq = `sequenceDiagram
  autonumber
  actor Client
  participant API as ${fullPath}
  
  Note over Client,API: ${note}

  Client->>API: ${labelReq}
${altBlocks}  end
\n`;

  const dir = path.join(DOCS_DIR, moduleName, 'sequenceDiagrams');
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  const fixedFullPath = util.toAnchorId( fullPath);
  const fileName = path.join(
    moduleName + '-' + method + '-' + fixedFullPath + '.mmd');
  const fullFileNameMermaid = path.join(dir, fileName);
  fs.writeFileSync(fullFileNameMermaid, seq, 'utf8');

  // create the png
  createMermaidImage(fullFileNameMermaid);

  return `\n![${labelReq} - Sequence Diagram](./sequenceDiagrams/${fileName.replace('.mmd', '.png')}){height="500px"}\n\n`;
}

// ---------- Group endpoints by module ----------
const modules = new Map(); // moduleName -> endpoints[]

for (const [p, methods] of Object.entries(spec.paths || {})) {
  // expect /api/<module>/...
  const parts = p.split('/').filter(Boolean);
  const moduleName = parts[1] || 'root'; // ["api","article",...]
  if (!modules.has(moduleName)) modules.set(moduleName, []);

  for (const [method, op] of Object.entries(methods)) {
    modules.get(moduleName).push({
      path: p,
      method: method.toUpperCase(),
      op,
    });
  }
}

fs.mkdirSync(DOCS_DIR, { recursive: true });

// ---------- Write per-module README ----------
for (const [moduleName, eps] of modules.entries()) {

  let dir = path.join(DOCS_DIR, moduleName);
  fs.mkdirSync(dir, { recursive: true });

  const usedSchemas = new Set();
  for (const e of eps) {
    collectSchemaRefs(e.op.responses, usedSchemas);
    collectSchemaRefs(e.op.requestBody, usedSchemas);
    collectSchemaRefs(e.op.parameters, usedSchemas);
  }

  let md = `# ${moduleName} ‚Äì API README\n\n`;

  md += '\n\n'
  md += '\n\n';
  md += '## Overview\n\n';
  md += `This is the API documentation for the module **${moduleName}**.\n\n`;
  md += 'The API is documented using OpenAPI 3.0.0.\n\n\n\n';
  md += '\n\n';
  md += '\n\n';

  md += `**Base Prefix:** /api/${moduleName}\n\n`;

  if (fs.existsSync(path.join(DOCS_DIR, moduleName, 'entities', '_erd.mmd'))){
    md += '\n\n';
    md += '\n\n';
    md += `![${moduleName} - Entity Diagram](./entities/_erd.png){height="450px"}\n\n`;
  }

  md += '\\tableofcontents\n\n';
  md += '\\newpage\n\n';


  // liste der Enpunkte auff√ºhren?

  const classDiagramSchemas = await classDiagramForSchemas(
    moduleName,
    usedSchemas,
  );
  const classDia = tsDtoClassSchemas(usedSchemas);
  const entityTs = tsEntityClassesForModule(moduleName);

  // Endpoints
  let first = true;
  md += `\\newpage\n## Endpoints {#endpoints}\n\n`;
  for (const e of eps) {
    const ret = guessReturnType(e.op);

    let name = `[${e.method}] ${e.path} --> ${ret}`;

    const anchor = util.toAnchorId(name);
    // anchor
    if (!first) {
      md += '\\newpage\n';
    }
    md += `### ${name} {#${anchor}}\n\n`;

    if (e.op.summary) md += `${e.op.summary.trim()}\n\n`;
    if (e.op.description) md += `${e.op.description.trim()}\n\n`;
    md += '\n';


    md += listParams(e.op) + '\n';

    const bodySchema = bodySchemaName(e.op);
    if (bodySchema) {
      md += `**Body Type:** [${bodySchema}](#${util.toAnchorId(bodySchema)})\n\n`;
    }

    if (ret) {
      md += `**Return Type:** [${ret}](#${util.toAnchorId(ret)})\n\n`;
    }

    // erstellen des sequence .mmd files
    const linksSequence = await sequenceDiagram(
      moduleName,
      e.method,
      e.path,
      e.op,
    );
    md += '\n';
    md += linksSequence;
    md += '\n';

    first = false;
  }

  // DTOs
  md += `\\newpage\n`;
  md += `## DTOs (class-schemas) {#dto-class-schemas}\n\n`;
  md += classDiagramSchemas;

  // erstellen des sequence .mmd files
  md += `\\newpage\n`;
  md += `## DTOs (TypeScript Classes) {#dto-classes}\n`;
  md += classDia;

  // Entities ERD (per module)
  const erdPath = path.join(DOCS_DIR, moduleName, 'entities', '_erd.mmd');
  if (fs.existsSync(erdPath)) {
    md += `\\newpage\n`;
    md += `## Entities (ERD) {#entities-erd}\n\n`;
    fs.readFileSync(erdPath, 'utf8');

    // create the svg
    void createMermaidImage(erdPath);
    md += '\n';
    md += `![${moduleName} - Entity Diagram](./entities/_erd.png){height="500px"}`;
    md += '\n\n';

    // wir zeigen den mermaid code nicht an, nur die Grafik
    // md += entityMermaid;
    // md += '\n\n';
  }

  // Entities TS classes (per module)
  if (entityTs) {
    md += `\\newpage\n`;
    md += `## Entities (TypeScript Classes) {#entities-ts}\n`;
    md += entityTs;
  }

  // sanitize
  md = md.replaceAll(/\n\n\n/g, '\n\n');
  md = md.replaceAll("-->", '‚Üí');

  const fileName = path.join(moduleName + '-README.md');
  const fullFilePath = path.join(dir, fileName);

  fs.writeFileSync(fullFilePath, md, 'utf8');
  // eslint-disable-next-line no-console
  console.log(`Wrote docs/${fileName}`);
}
