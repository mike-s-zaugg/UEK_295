// scripts/generate-module-readmes.mjs
//
// Generates per-module README files from OpenAPI + per-module ERD/Entity metadata.
// Inputs:
// - docs/openapi.json
// - docs/<module>/_erd.md            (generated by scripts/generate-erd-per-module.mjs)
// - docs/<module>/_entities.json     (also generated by scripts/generate-erd-per-module.mjs)
//
// Output:
// - docs/<module>/README.md
//
// Notes:
// - Groups endpoints by path: /api/<module>/...
// - Adds Mermaid sequence diagrams with status code labels + response types
// - Adds DTO Mermaid classDiagram + TypeScript DTO classes (from OpenAPI schemas)
// - Adds Entities Mermaid ERD + TypeScript Entity classes (from TypeORM metadata JSON)
//
import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import * as util from './util.mjs';

async function renderMarkdownToPdf(
  inputMdRelFromRoot,
  projectRoot = process.cwd(),
) {
  const inputMdAbs = path.resolve(projectRoot, inputMdRelFromRoot);
  const mdDirAbs = path.dirname(inputMdAbs);
  const mdDirParentAbs = path.dirname(mdDirAbs);

  const fileName = path.basename(inputMdAbs);
  const pdfAbsPath = path.join(mdDirParentAbs, fileName);
  const pdfAbs = pdfAbsPath.replace(/\.md$/i, '.pdf');

  const headerTex = path.resolve(projectRoot, 'scripts/pandoc-header.tex');

  // sanity checks
  if (!fs.existsSync(inputMdAbs))
    throw new Error(`MD nicht gefunden: ${inputMdAbs}`);
  if (!fs.existsSync(headerTex))
    throw new Error(`Header nicht gefunden: ${headerTex}`);

  // tooling checks
  await util.assertCommand('pandoc', 'Install: winget install pandoc');
  await util.assertCommand(
    'xelatex',
    'Install: winget install MiKTeX.MiKTeX (oder TeX Live)',
  );

  // Font-Fallback für Windows (DejaVu ist nicht garantiert vorhanden)
  const mainfont = os.platform() === 'win32' ? 'Calibri' : 'DejaVu Sans';
  const monofont = os.platform() === 'win32' ? 'Consolas' : 'DejaVu Sans Mono';

  const args = [
    inputMdAbs,
    '-o',
    pdfAbs,
    `--resource-path=${mdDirAbs}`, // Bilder relativ zur MD finden
    '--pdf-engine=xelatex',
    `--include-in-header=${headerTex}`,
    '-V',
    'figurePlacement=H',
    '--highlight-style=tango',
    '-V',
    'geometry:margin=2cm',
    '--toc-depth=3',
    '--number-sections',
    // '--top-level-division=chapter',
    // page options:
    '-V',
    'documentclass=report',
    '-V',
    'classoption=oneside',
    '-V',
    'classoption=openany',
    // Fonts:
    '-V',
    `mainfont=${mainfont}`,
    '-V',
    `monofont=${monofont}`,
  ];

  try {
    console.log(`PDF ${pdfAbs} wird erstellt....`);

    await util.runCommand('pandoc', args, { cwd: projectRoot });
    // remove no logger required files
    // fs.rmSync(mdDirAbs, { recursive: true, force: true });
    console.log(`PDF ${pdfAbs} erstellt ✅`);
  } catch(e) {
    console.error(`PDF ${pdfAbs} konnte nicht erstellt werden: ${e}`);
  }
}

async function processReadmes(baseDir) {
  const entries = fs.readdirSync(baseDir, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const subFolderPath = path.join(baseDir, entry.name);
    const files = fs.readdirSync(subFolderPath);

    for (const file of files) {
      if (file.toLocaleLowerCase().endsWith('-readme.md')) {
        const fullPath = path.join(subFolderPath, file);
         await renderMarkdownToPdf(fullPath);
      }
    }
  }
}

// Aufruf
processReadmes("./docs").catch(console.error);